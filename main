import pygame
import sys
import random
import cv2

import mediapipe as mp
import numpy as np

mp_face = mp.solutions.face_mesh
mp_drawing = mp.solutions.drawing_utils
LEFT_EYE_IDX = [362, 380, 374, 263, 386, 385]
RIGHT_EYE_IDX = [33, 159, 158, 133, 153, 145]
THRESH = 0.2

face = mp_face.FaceMesh(
    max_num_faces=1,
    refine_landmarks=True,
    min_detection_confidence=0.5,
    min_tracking_confidence=0.5
)

def landmarktonp(landmark):
    return np.array([landmark.x, landmark.y, landmark.z])

def eye_aspect_ratio(eye_landmarks, landmarks):
    
    A = np.linalg.norm(np.array(landmarktonp(landmarks[eye_landmarks[1]])) - 
                       np.array(landmarktonp(landmarks[eye_landmarks[5]])))
    B = np.linalg.norm(np.array(landmarktonp(landmarks[eye_landmarks[2]])) - 
                       np.array(landmarktonp(landmarks[eye_landmarks[4]])))
    C = np.linalg.norm(np.array(landmarktonp(landmarks[eye_landmarks[0]])) - 
                       np.array(landmarktonp(landmarks[eye_landmarks[3]])))
    return (A + B) / (2.0 * C)

pygame.init()
WIDTH, HEIGHT = 720, 360
GRAV = 0.5
MOVE = -5
PWINDOW = 150
N = 4
LASERWIDTH = 15

pillars = []

class Button():
    def __init__(self, rect):
        self.rect = rect
    
    def check(self):
        pos = pygame.mouse.get_pos()
        if self.rect.collidepoint(pos):
            return True
        return False

class Bird():
    def __init__(self):
        self.pos = [WIDTH/4, HEIGHT/2]
        self.vel = [0, 0]
        self.size = [30, 30]
        self.rect = pygame.Rect(*self.pos, *self.size) 
        self.jump = False
        self.bounds = [0, HEIGHT-self.size[0]]

    def update(self):
        self.vel[1] += GRAV
        if self.jump:
            self.vel[1] = MOVE

        self.pos[1] += self.vel[1]
        self.rect = pygame.Rect(*self.pos, *self.size)
        self.jump = False
        
        if self.pos[1] < self.bounds[0] or self.pos[1] > self.bounds[1]:
            return True
        return False

class Pillars():
    def __init__(self, initwin:int=None):
        self.pos = WIDTH
        self.window_size = PWINDOW
        
        self.win_start = random.random() * (HEIGHT-60) + 30 if initwin is None else initwin + 6*PWINDOW*random.random()-3*PWINDOW
        while self.win_start > HEIGHT-PWINDOW or self.win_start < PWINDOW:
            self.win_start = random.random() * (HEIGHT-60) + 30 if initwin is None else initwin + 6*PWINDOW*random.random()-3*PWINDOW

        self.rect1_y = self.win_start
        self.rect2_y = self.win_start+PWINDOW
        
        self.crazy_pillars = False #TODO: change this to be random af 
        self.rect1 = pygame.Rect(self.pos, 0, 30, self.win_start)
        self.rect2 = pygame.Rect(self.pos, self.win_start + PWINDOW, 30, HEIGHT)
        self.gen_flag = True
        self.up = False if random.random() > .5 else True 
        self.scored = False

    def update(self):
        self.pos -= 4
        if self.pos < -30:
            pillars.remove(self)
        
        if self.crazy_pillars:
            if self.pos < WIDTH / 2+30 and self.pos > WIDTH/2 :
                if self.up:
                    self.win_start += 7
                else:
                    self.win_start -= 7

        if self.pos < WIDTH *.75 and len(pillars) < N and self.gen_flag:
            pillars.append(Pillars())#pillars[-1].win_start+PWINDOW/2))
            self.gen_flag = False
            
        self.rect1 = pygame.Rect(self.pos, 0, 30, self.win_start)
        self.rect2 = pygame.Rect(self.pos, self.win_start + PWINDOW, 30, HEIGHT)

class Laser():
    def __init__(self, pos):
        self.pos = pos
        self.tick = 0
        self.state = 'ready'
        self.ready = 50
        self.more_ready = 20
        self.fire = 5
        self.dead = 100
        self.rect = pygame.Rect(0, self.pos, WIDTH, LASERWIDTH)

    def update(self, pos):
        self.tick += 1
        if self.tick <= self.ready:
            self.state = 'ready'
            self.pos += (pos - self.pos) / 10
            self.rect = pygame.Rect(0, self.pos, WIDTH, LASERWIDTH)
        elif self.tick > self.ready and self.tick <= self.ready + self.more_ready:
            self.staet = 'more_ready'
            
        elif self.tick > self.ready+self.more_ready and self.tick <= self.ready + self.fire + self.more_ready:
            self.state = 'fire'
            self.pos = random.random()*HEIGHT
    
        elif self.tick > self.ready + self.more_ready+ self.fire and self.tick <= self.ready + self.more_ready+ self.fire + self.dead:
            self.state = 'dead'
        else:
            self.tick = 0
            
def menu(screen, score):
    global pillars
    pillars = []
    retry_button = Button(pygame.Rect(2*WIDTH/5, 2*HEIGHT/5, WIDTH/5, HEIGHT/5))
    while True:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit(0)
            elif event.type == pygame.MOUSEBUTTONDOWN or event.type == pygame.KEYDOWN:
                if retry_button.check():
                    main()

        pygame.draw.rect(screen, 'green', pygame.Rect(WIDTH/3, HEIGHT/3, WIDTH/3, HEIGHT/3))
        pygame.draw.rect(screen, 'blue', retry_button.rect)

        pygame.display.flip()

def main():
    screen = pygame.display.set_mode((WIDTH, HEIGHT))
    clock = pygame.time.Clock()
    bird = Bird()
    pillars.append(Pillars())
    laser = Laser(0)
    laser_on = False
    laser_color = 30
    score = 0
    laser_kill = False

    cap = cv2.VideoCapture(0)

    while True:
        ret, frame = cap.read()

        #h, w = frame.shape[:2]
        img_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        results = face.process(img_rgb)
        
        closed_eyes = 0
        if results.multi_face_landmarks:
            landmarks = results.multi_face_landmarks[0].landmark
            #for idx in LEFT_EYE_IDX:
            #x = int(landmarks[idx].x * w)
            #y = int(landmarks[idx].y * h)
            #cv2.circle(frame, (x, y), 2, (0, 255, 0), -1)
            if eye_aspect_ratio(LEFT_EYE_IDX, landmarks)<THRESH:
                closed_eyes +=1
            # Draw right eye
            #for idx in RIGHT_EYE_IDX:
                #x = int(landmarks[idx].x * w)
                #y = int(landmarks[idx].y * h)
                #cv2.circle(frame, (x, y), 2, (0, 255, 0), -1)
            if eye_aspect_ratio(RIGHT_EYE_IDX, landmarks)<THRESH:
                closed_eyes +=1

        if closed_eyes==2: 
            bird.jump = True

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit(0)
            elif event.type == pygame.KEYDOWN:
                bird.jump = True
        
        floor = bird.update()
        laser.update(bird.pos[1])

        screen.fill('black')

        if laser_on:
            laser_kill = False
            if laser.state == 'ready':
                laser_color += 3
                pygame.draw.rect(screen, (laser_color, laser_color, laser_color), laser.rect)
            elif laser.state == 'more_ready':
                pygame.draw.rect(screen, (laser_color, 0, laser_color//3), laser.rect)
            elif laser.state == 'fire':
                pygame.draw.rect(screen, (laser_color, 0, 0), laser.rect)
                laser_kill = bird.rect.colliderect(laser.rect)
            else:
                laser_color = 30

        pygame.draw.rect(screen, 'red', bird.rect)

        collide = False
        for pillar in pillars:
            pillar.update()
            pygame.draw.rect(screen, 'blue', pillar.rect1)
            pygame.draw.rect(screen, 'blue', pillar.rect2)
            collide = collide or bird.rect.colliderect(pillar.rect1) or bird.rect.colliderect(pillar.rect2)
            if not pillar.scored and pillar.pos < bird.pos[0]:
                score += 1
                pillar.scored = True
                
        if floor or collide or laser_kill:
            break
        
        pygame.display.flip()
        clock.tick(30)

    menu(screen, score=score)

if __name__ == '__main__':
    main()
